diff -urN tempuboot2017/u-boot-2017.01/arch/arm/cpu/arm920t/Kconfig ./u-boot-2017.01/arch/arm/cpu/arm920t/Kconfig
--- tempuboot2017/u-boot-2017.01/arch/arm/cpu/arm920t/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ ./u-boot-2017.01/arch/arm/cpu/arm920t/Kconfig	2019-12-30 04:29:22.733453542 -0800
@@ -0,0 +1,4 @@
+config S3C24X0
+	bool "config s3c24x0"
+	default y
+
diff -urN tempuboot2017/u-boot-2017.01/arch/arm/cpu/arm920t/s3c24x0/Makefile ./u-boot-2017.01/arch/arm/cpu/arm920t/s3c24x0/Makefile
--- tempuboot2017/u-boot-2017.01/arch/arm/cpu/arm920t/s3c24x0/Makefile	2017-01-09 08:57:05.000000000 -0800
+++ ./u-boot-2017.01/arch/arm/cpu/arm920t/s3c24x0/Makefile	2019-12-31 00:19:03.749931297 -0800
@@ -9,3 +9,4 @@
 obj-$(CONFIG_DISPLAY_CPUINFO)	+= cpu_info.o
 obj-y	+= speed.o
 obj-y	+= timer.o
+obj-y   += serial.o
diff -urN tempuboot2017/u-boot-2017.01/arch/arm/cpu/arm920t/s3c24x0/serial.c ./u-boot-2017.01/arch/arm/cpu/arm920t/s3c24x0/serial.c
--- tempuboot2017/u-boot-2017.01/arch/arm/cpu/arm920t/s3c24x0/serial.c	1969-12-31 16:00:00.000000000 -0800
+++ ./u-boot-2017.01/arch/arm/cpu/arm920t/s3c24x0/serial.c	2019-12-31 00:22:45.451757014 -0800
@@ -0,0 +1,185 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <common.h>
+
+
+#include <asm/arch-s3c24x0/s3c24x0_cpu.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifdef CONFIG_SERIAL1
+#define UART_NR	S3C24X0_UART0
+
+#elif defined(CONFIG_SERIAL2)
+# if defined(CONFIG_TRAB)
+#  error "TRAB supports only CONFIG_SERIAL1"
+# endif
+#define UART_NR	S3C24X0_UART1
+
+#elif defined(CONFIG_SERIAL3)
+# if defined(CONFIG_TRAB)
+#  #error "TRAB supports only CONFIG_SERIAL1"
+# endif
+#define UART_NR	S3C24X0_UART2
+
+#else
+#error "Bad: you didn't configure serial ..."
+#endif
+
+void serial_setbrg (void)
+{
+	struct s3c24x0_uart* uart = s3c24x0_get_base_uart(UART_NR);
+	int i;
+	unsigned int reg = 0;
+
+	/* value is calculated so : (int)(PCLK/16./baudrate) -1 */
+	reg = get_PCLK() / (16 * gd->baudrate) - 1;
+
+	/* FIFO enable, Tx/Rx FIFO clear */
+	uart->ufcon = 0x07;
+	uart->umcon = 0x0;
+	/* Normal,No parity,1 stop,8 bit */
+	uart->ulcon = 0x3;
+	/*
+	 * tx=level,rx=edge,disable timeout int.,enable rx error int.,
+	 * normal,interrupt or polling
+	 */
+	uart->ucon = 0x245;
+	uart->ubrdiv = reg;
+
+#ifdef CONFIG_HWFLOW
+	uart->umcon = 0x1; /* RTS up */
+#endif
+	for (i = 0; i < 100; i++);
+}
+
+/*
+ * Initialise the serial port with the given baudrate. The settings
+ * are always 8 data bits, no parity, 1 stop bit, no start bits.
+ *
+ */
+int serial_init (void)
+{
+	serial_setbrg ();
+
+	return (0);
+}
+
+/*
+ * Read a single byte from the serial port. Returns 1 on success, 0
+ * otherwise. When the function is succesfull, the character read is
+ * written into its argument c.
+ */
+int serial_getc (void)
+{
+	struct s3c24x0_uart* uart = s3c24x0_get_base_uart(UART_NR);
+
+	/* wait for character to arrive */
+	while (!(uart->utrstat & 0x1));
+
+	return uart->urxh & 0xff;
+}
+
+#ifdef CONFIG_HWFLOW
+static int hwflow = 0; /* turned off by default */
+int hwflow_onoff(int on)
+{
+	switch(on) {
+	case 0:
+	default:
+		break; /* return current */
+	case 1:
+		hwflow = 1; /* turn on */
+		break;
+	case -1:
+		hwflow = 0; /* turn off */
+		break;
+	}
+	return hwflow;
+}
+#endif
+
+#ifdef CONFIG_MODEM_SUPPORT
+static int be_quiet = 0;
+void disable_putc(void)
+{
+	be_quiet = 1;
+}
+
+void enable_putc(void)
+{
+	be_quiet = 0;
+}
+#endif
+
+
+/*
+ * Output a single byte to the serial port.
+ */
+void serial_putc (const char c)
+{
+	struct s3c24x0_uart* uart = s3c24x0_get_base_uart(UART_NR);
+#ifdef CONFIG_MODEM_SUPPORT
+	if (be_quiet)
+		return;
+#endif
+
+	/* wait for room in the tx FIFO */
+	while (!(uart->utrstat & 0x2));
+
+#ifdef CONFIG_HWFLOW
+	/* Wait for CTS up */
+	while(hwflow && !(uart->umstat & 0x1))
+		;
+#endif
+
+	uart->utxh = c;
+
+	/* If \n, also do \r */
+	if (c == '\n')
+		serial_putc ('\r');
+}
+
+/*
+ * Test whether a character is in the RX buffer
+ */
+int serial_tstc (void)
+{
+	struct s3c24x0_uart* uart = s3c24x0_get_base_uart(UART_NR);
+
+	return uart->utrstat & 0x1;
+}
+
+void
+serial_puts (const char *s)
+{
+	while (*s) {
+		serial_putc (*s++);
+	}
+}
+
+
+
+/**stub**/
+void serial_initialize(void) {};
+void serial_stdio_init(void) {};
+
+
diff -urN tempuboot2017/u-boot-2017.01/arch/arm/cpu/arm920t/s3c24x0/speed.c ./u-boot-2017.01/arch/arm/cpu/arm920t/s3c24x0/speed.c
--- tempuboot2017/u-boot-2017.01/arch/arm/cpu/arm920t/s3c24x0/speed.c	2017-01-09 08:57:05.000000000 -0800
+++ ./u-boot-2017.01/arch/arm/cpu/arm920t/s3c24x0/speed.c	2019-12-30 05:31:11.070462817 -0800
@@ -17,7 +17,7 @@
 #ifdef CONFIG_S3C24X0
 
 #include <asm/io.h>
-#include <asm/arch/s3c24x0_cpu.h>
+#include <asm/arch-s3c24x0/s3c24x0_cpu.h>
 
 #define MPLL 0
 #define UPLL 1
diff -urN tempuboot2017/u-boot-2017.01/arch/arm/cpu/arm920t/s3c24x0/timer.c ./u-boot-2017.01/arch/arm/cpu/arm920t/s3c24x0/timer.c
--- tempuboot2017/u-boot-2017.01/arch/arm/cpu/arm920t/s3c24x0/timer.c	2017-01-09 08:57:05.000000000 -0800
+++ ./u-boot-2017.01/arch/arm/cpu/arm920t/s3c24x0/timer.c	2019-12-30 05:36:53.772922654 -0800
@@ -17,7 +17,7 @@
 #ifdef CONFIG_S3C24X0
 
 #include <asm/io.h>
-#include <asm/arch/s3c24x0_cpu.h>
+#include <asm/arch-s3c24x0/s3c24x0_cpu.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
diff -urN tempuboot2017/u-boot-2017.01/arch/arm/include/asm/arch-s3c24x0/s3c2440.h ./u-boot-2017.01/arch/arm/include/asm/arch-s3c24x0/s3c2440.h
--- tempuboot2017/u-boot-2017.01/arch/arm/include/asm/arch-s3c24x0/s3c2440.h	2017-01-09 08:57:05.000000000 -0800
+++ ./u-boot-2017.01/arch/arm/include/asm/arch-s3c24x0/s3c2440.h	2019-12-30 05:36:14.049564824 -0800
@@ -49,7 +49,7 @@
 #define S3C2440_SDI_BASE		0x5A000000
 
 /* include common stuff */
-#include <asm/arch/s3c24x0.h>
+#include <asm/arch-s3c24x0/s3c24x0.h>
 
 static inline struct s3c24x0_memctl *s3c24x0_get_base_memctl(void)
 {
diff -urN tempuboot2017/u-boot-2017.01/arch/arm/include/asm/arch-s3c24x0/s3c24x0_cpu.h ./u-boot-2017.01/arch/arm/include/asm/arch-s3c24x0/s3c24x0_cpu.h
--- tempuboot2017/u-boot-2017.01/arch/arm/include/asm/arch-s3c24x0/s3c24x0_cpu.h	2017-01-09 08:57:05.000000000 -0800
+++ ./u-boot-2017.01/arch/arm/include/asm/arch-s3c24x0/s3c24x0_cpu.h	2019-12-30 05:33:51.803864380 -0800
@@ -6,11 +6,11 @@
  */
 
 #ifdef CONFIG_S3C2400
-	#include <asm/arch/s3c2400.h>
+	#include <asm/arch-s3c24x0/s3c2400.h>
 #elif defined CONFIG_S3C2410
-	#include <asm/arch/s3c2410.h>
+	#include <asm/arch-s3c24x0/s3c2410.h>
 #elif defined CONFIG_S3C2440
-	#include <asm/arch/s3c2440.h>
+	#include <asm/arch-s3c24x0/s3c2440.h>
 #else
 	#error Please define the s3c24x0 cpu type
 #endif
diff -urN tempuboot2017/u-boot-2017.01/arch/arm/Kconfig ./u-boot-2017.01/arch/arm/Kconfig
--- tempuboot2017/u-boot-2017.01/arch/arm/Kconfig	2017-01-09 08:57:05.000000000 -0800
+++ ./u-boot-2017.01/arch/arm/Kconfig	2019-12-30 04:30:36.963909126 -0800
@@ -917,6 +917,9 @@
 	select OF_CONTROL
 	select SYS_CACHE_SHIFT_7
 
+config TARGET_S3C2440
+	bool "support S3C2440"
+	select CPU_ARM920T
 endchoice
 
 source "arch/arm/mach-at91/Kconfig"
@@ -981,6 +984,8 @@
 
 source "arch/arm/imx-common/Kconfig"
 
+source "arch/arm/cpu/arm920t/Kconfig"
+
 source "board/bosch/shc/Kconfig"
 source "board/BuR/brxre1/Kconfig"
 source "board/BuR/brppt1/Kconfig"
@@ -1066,7 +1071,7 @@
 source "board/woodburn/Kconfig"
 source "board/work-microwave/work_92105/Kconfig"
 source "board/zipitz2/Kconfig"
-
+source "board/samsung/smdk2440/Kconfig"
 source "arch/arm/Kconfig.debug"
 
 endmenu
diff -urN tempuboot2017/u-boot-2017.01/arch/arm/Makefile ./u-boot-2017.01/arch/arm/Makefile
--- tempuboot2017/u-boot-2017.01/arch/arm/Makefile	2017-01-09 08:57:05.000000000 -0800
+++ ./u-boot-2017.01/arch/arm/Makefile	2019-09-04 18:30:31.682902537 -0700
@@ -9,7 +9,7 @@
 
 # This selects which instruction set is used.
 arch-$(CONFIG_CPU_ARM720T)	=-march=armv4
-arch-$(CONFIG_CPU_ARM920T)	=-march=armv4t
+arch-$(CONFIG_CPU_ARM920T)	=-march=armv4
 arch-$(CONFIG_CPU_ARM926EJS)	=-march=armv5te
 arch-$(CONFIG_CPU_ARM946ES)	=-march=armv5te
 arch-$(CONFIG_CPU_SA1100)	=-march=armv4
diff -urN tempuboot2017/u-boot-2017.01/board/samsung/smdk2440/flash.c ./u-boot-2017.01/board/samsung/smdk2440/flash.c
--- tempuboot2017/u-boot-2017.01/board/samsung/smdk2440/flash.c	1969-12-31 16:00:00.000000000 -0800
+++ ./u-boot-2017.01/board/samsung/smdk2440/flash.c	2019-12-31 23:33:21.527976309 -0800
@@ -0,0 +1,445 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Alex Zuepke <azu@sysgo.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+ulong myflush (void);
+
+
+#define FLASH_BANK_SIZE	PHYS_FLASH_SIZE
+#define MAIN_SECT_SIZE  0x10000	/* 64 KB */
+
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS];
+
+
+#define CMD_READ_ARRAY		0x000000F0
+#define CMD_UNLOCK1		0x000000AA
+#define CMD_UNLOCK2		0x00000055
+#define CMD_ERASE_SETUP		0x00000080
+#define CMD_ERASE_CONFIRM	0x00000030
+#define CMD_PROGRAM		0x000000A0
+#define CMD_UNLOCK_BYPASS	0x00000020
+
+#define MEM_FLASH_ADDR1		(*(volatile u16 *)(CFG_FLASH_BASE + (0x00000555 << 1)))
+#define MEM_FLASH_ADDR2		(*(volatile u16 *)(CFG_FLASH_BASE + (0x000002AA << 1)))
+
+#define BIT_ERASE_DONE		0x00000080
+#define BIT_RDY_MASK		0x00000080
+#define BIT_PROGRAM_ERROR	0x00000020
+#define BIT_TIMEOUT		0x80000000	/* our flag */
+
+#define READY 1
+#define ERR   2
+#define TMO   4
+
+/*-----------------------------------------------------------------------
+ */
+
+ulong flash_init (void)
+{
+	int i, j;
+	ulong size = 0;
+
+	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
+		ulong flashbase = 0;
+
+		flash_info[i].flash_id =
+#if defined(CONFIG_AMD_LV400)
+			(AMD_MANUFACT & FLASH_VENDMASK) |
+			(AMD_ID_LV400B & FLASH_TYPEMASK);
+#elif defined(CONFIG_AMD_LV800)
+			(AMD_MANUFACT & FLASH_VENDMASK) |
+			(AMD_ID_LV800B & FLASH_TYPEMASK);
+#else
+#error "Unknown flash configured"
+#endif
+			flash_info[i].size = FLASH_BANK_SIZE;
+		flash_info[i].sector_count = CFG_MAX_FLASH_SECT;
+		memset (flash_info[i].protect, 0, CFG_MAX_FLASH_SECT);
+		if (i == 0)
+			flashbase = PHYS_FLASH_1;
+		else
+			panic ("configured too many flash banks!\n");
+		for (j = 0; j < flash_info[i].sector_count; j++) {
+			if (j <= 3) {
+				/* 1st one is 16 KB */
+				if (j == 0) {
+					flash_info[i].start[j] =
+						flashbase + 0;
+				}
+
+				/* 2nd and 3rd are both 8 KB */
+				if ((j == 1) || (j == 2)) {
+					flash_info[i].start[j] =
+						flashbase + 0x4000 + (j -
+								      1) *
+						0x2000;
+				}
+
+				/* 4th 32 KB */
+				if (j == 3) {
+					flash_info[i].start[j] =
+						flashbase + 0x8000;
+				}
+			} else {
+				flash_info[i].start[j] =
+					flashbase + (j - 3) * MAIN_SECT_SIZE;
+			}
+		}
+		size += flash_info[i].size;
+	}
+
+	flash_protect (FLAG_PROTECT_SET,
+		       CFG_FLASH_BASE,
+		       CFG_FLASH_BASE + monitor_flash_len - 1,
+		       &flash_info[0]);
+
+	flash_protect (FLAG_PROTECT_SET,
+		       CFG_ENV_ADDR,
+		       CFG_ENV_ADDR + CFG_ENV_SIZE - 1, &flash_info[0]);
+
+	return size;
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+#if 1
+
+	int i;
+	switch (info->flash_id & FLASH_VENDMASK) {
+	case (AMD_MANUFACT & FLASH_VENDMASK):
+		printf ("AMD: ");
+		break;
+	default:
+		printf ("Unknown Vendor ");
+		break;
+	}
+
+	switch (info->flash_id & FLASH_TYPEMASK) {
+	case (AMD_ID_LV400B & FLASH_TYPEMASK):
+		printf ("1x Amd29LV400BB (4Mbit)\n");
+		break;
+	case (AMD_ID_LV800B & FLASH_TYPEMASK):
+		printf ("1x Amd29LV800BB (8Mbit)\n");
+		break;
+	default:
+		printf ("Unknown Chip Type\n");
+		goto Done;
+		break;
+	}
+
+	printf ("  Size: %ld MB in %d Sectors\n",
+		info->size >> 20, info->sector_count);
+
+	printf ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; i++) {
+		if ((i % 5) == 0) {
+			printf ("\n   ");
+		}
+		printf (" %08lX%s", info->start[i],
+			info->protect[i] ? " (RO)" : "     ");
+	}
+	printf ("\n");
+
+      Done:;
+#endif
+}
+
+/*-----------------------------------------------------------------------
+ */
+
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+#if 0
+
+	ushort result;
+	int iflag, cflag, prot, sect;
+	int rc = ERR_OK;
+	int chip;
+	/* first look for protection bits */
+
+	if (info->flash_id == FLASH_UNKNOWN)
+		return ERR_UNKNOWN_FLASH_TYPE;
+
+	if ((s_first < 0) || (s_first > s_last)) {
+		return ERR_INVAL;
+	}
+
+	if ((info->flash_id & FLASH_VENDMASK) !=
+	    (AMD_MANUFACT & FLASH_VENDMASK)) {
+		return ERR_UNKNOWN_FLASH_VENDOR;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot)
+		return ERR_PROTECTED;
+
+	/*
+	 * Disable interrupts which might cause a timeout
+	 * here. Remember that our exception vectors are
+	 * at address 0 in the flash, and we don't want a
+	 * (ticker) exception to happen while the flash
+	 * chip is in programming mode.
+	 */
+	cflag = icache_status ();
+	icache_disable ();
+	iflag = disable_interrupts ();
+
+	/* Start erase on unprotected sectors */
+	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
+		printf ("Erasing sector %2d ... ", sect);
+
+		/* arm simple, non interrupt dependent timer */
+		reset_timer_masked ();
+
+		if (info->protect[sect] == 0) {	/* not protected */
+			vu_short *addr = (vu_short *) (info->start[sect]);
+
+			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+			MEM_FLASH_ADDR1 = CMD_ERASE_SETUP;
+
+			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+			*addr = CMD_ERASE_CONFIRM;
+
+			/* wait until flash is ready */
+			chip = 0;
+
+			do {
+				result = *addr;
+
+				/* check timeout */
+				if (get_timer_masked () >
+				    CFG_FLASH_ERASE_TOUT) {
+					MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
+					chip = TMO;
+					break;
+				}
+
+				if (!chip
+				    && (result & 0xFFFF) & BIT_ERASE_DONE)
+					chip = READY;
+
+				if (!chip
+				    && (result & 0xFFFF) & BIT_PROGRAM_ERROR)
+					chip = ERR;
+
+			} while (!chip);
+
+			MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
+
+			if (chip == ERR) {
+				rc = ERR_PROG_ERROR;
+				goto outahere;
+			}
+			if (chip == TMO) {
+				rc = ERR_TIMOUT;
+				goto outahere;
+			}
+
+			printf ("ok.\n");
+		} else {	/* it was protected */
+
+			printf ("protected!\n");
+		}
+	}
+
+	if (ctrlc ())
+		printf ("User Interrupt!\n");
+
+      outahere:
+	/* allow flash to settle - wait 10 ms */
+	udelay_masked (10000);
+
+	if (iflag)
+		enable_interrupts ();
+
+	if (cflag)
+		icache_enable ();
+	
+	return rc;
+#endif
+	return 0;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash
+ */
+
+volatile static int write_hword (flash_info_t * info, ulong dest, ushort data)
+{
+#if 0
+
+	vu_short *addr = (vu_short *) dest;
+	ushort result;
+	int rc = ERR_OK;
+	int cflag, iflag;
+	int chip;
+	/*
+	 * Check if Flash is (sufficiently) erased
+	 */
+	result = *addr;
+	if ((result & data) != data)
+		return ERR_NOT_ERASED;
+
+
+	/*
+	 * Disable interrupts which might cause a timeout
+	 * here. Remember that our exception vectors are
+	 * at address 0 in the flash, and we don't want a
+	 * (ticker) exception to happen while the flash
+	 * chip is in programming mode.
+	 */
+	cflag = icache_status ();
+	icache_disable ();
+	iflag = disable_interrupts ();
+
+	MEM_FLASH_ADDR1 = CMD_UNLOCK1;
+	MEM_FLASH_ADDR2 = CMD_UNLOCK2;
+	MEM_FLASH_ADDR1 = CMD_UNLOCK_BYPASS;
+	*addr = CMD_PROGRAM;
+	*addr = data;
+
+	/* arm simple, non interrupt dependent timer */
+	reset_timer_masked ();
+
+	/* wait until flash is ready */
+	chip = 0;
+	do {
+		result = *addr;
+
+		/* check timeout */
+		if (get_timer_masked () > CFG_FLASH_ERASE_TOUT) {
+			chip = ERR | TMO;
+			break;
+		}
+		if (!chip && ((result & 0x80) == (data & 0x80)))
+			chip = READY;
+
+		if (!chip && ((result & 0xFFFF) & BIT_PROGRAM_ERROR)) {
+			result = *addr;
+
+			if ((result & 0x80) == (data & 0x80))
+				chip = READY;
+			else
+				chip = ERR;
+		}
+
+	} while (!chip);
+
+	*addr = CMD_READ_ARRAY;
+
+	if (chip == ERR || *addr != data)
+		rc = ERR_PROG_ERROR;
+
+	if (iflag)
+		enable_interrupts ();
+
+	if (cflag)
+		icache_enable ();
+	return rc;
+#endif
+return 0;
+
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash.
+ */
+
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+#if 0
+
+	ulong cp, wp;
+	int l;
+	int i, rc;
+	ushort data;
+	wp = (addr & ~1);	/* get lower word aligned address */
+
+	/*
+	 * handle unaligned start bytes
+	 */
+	if ((l = addr - wp) != 0) {
+		data = 0;
+		for (i = 0, cp = wp; i < l; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+		for (; i < 2 && cnt > 0; ++i) {
+			data = (data >> 8) | (*src++ << 8);
+			--cnt;
+			++cp;
+		}
+		for (; cnt == 0 && i < 2; ++i, ++cp) {
+			data = (data >> 8) | (*(uchar *) cp << 8);
+		}
+
+		if ((rc = write_hword (info, wp, data)) != 0) {
+			return (rc);
+		}
+		wp += 2;
+	}
+
+	/*
+	 * handle word aligned part
+	 */
+	while (cnt >= 2) {
+		data = *((vu_short *) src);
+		if ((rc = write_hword (info, wp, data)) != 0) {
+			return (rc);
+		}
+		src += 2;
+		wp += 2;
+		cnt -= 2;
+	}
+
+	if (cnt == 0) {
+		return ERR_OK;
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	data = 0;
+	for (i = 0, cp = wp; i < 2 && cnt > 0; ++i, ++cp) {
+		data = (data >> 8) | (*src++ << 8);
+		--cnt;
+	}
+	for (; i < 2; ++i, ++cp) {
+		data = (data >> 8) | (*(uchar *) cp << 8);
+	}
+
+	return write_hword (info, wp, data);
+#endif
+	
+return 0;
+}
diff -urN tempuboot2017/u-boot-2017.01/board/samsung/smdk2440/Kconfig ./u-boot-2017.01/board/samsung/smdk2440/Kconfig
--- tempuboot2017/u-boot-2017.01/board/samsung/smdk2440/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ ./u-boot-2017.01/board/samsung/smdk2440/Kconfig	2019-12-30 05:20:58.652363221 -0800
@@ -0,0 +1,11 @@
+if TARGET_S3C2440
+
+config SYS_BOARD
+	default "smdk2440"
+
+config SYS_VENDOR
+	default "samsung"
+
+config SYS_CONFIG_NAME
+	default "smdk2440"
+endif
diff -urN tempuboot2017/u-boot-2017.01/board/samsung/smdk2440/lowlevel_init.S ./u-boot-2017.01/board/samsung/smdk2440/lowlevel_init.S
--- tempuboot2017/u-boot-2017.01/board/samsung/smdk2440/lowlevel_init.S	1969-12-31 16:00:00.000000000 -0800
+++ ./u-boot-2017.01/board/samsung/smdk2440/lowlevel_init.S	2020-01-01 03:58:29.630189146 -0800
@@ -0,0 +1,216 @@
+/*
+ * Memory Setup stuff - taken from blob memsetup.S
+ *
+ * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl) and
+ *                     Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl)
+ *
+ * Modified for the Samsung SMDK2410 by
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+
+
+/* some parameters for the board */
+
+/*
+ *
+ * Taken from linux/arch/arm/boot/compressed/head-s3c2410.S
+ *
+ * Copyright (C) 2002 Samsung Electronics SW.LEE  <hitchcar@sec.samsung.com>
+ *
+ */
+
+#define BWSCON	0x48000000
+
+/* BWSCON */
+#define DW8		 	(0x0)
+#define DW16		 	(0x1)
+#define DW32		 	(0x2)
+#define WAIT		 	(0x1<<2)
+#define UBLB		 	(0x1<<3)
+
+#define B1_BWSCON	  	(DW32)
+#define B2_BWSCON	  	(DW16)
+#define B3_BWSCON	  	(DW16 + WAIT + UBLB)
+#define B4_BWSCON	  	(DW16)
+#define B5_BWSCON	  	(DW16)
+#define B6_BWSCON	  	(DW32)
+#define B7_BWSCON	  	(DW32)
+
+/* BANK0CON */
+#define B0_Tacs		 	0x0	/*  0clk */
+#define B0_Tcos		 	0x0	/*  0clk */
+#define B0_Tacc		 	0x7	/* 14clk */
+#define B0_Tcoh		 	0x0	/*  0clk */
+#define B0_Tah		 	0x0	/*  0clk */
+#define B0_Tacp		 	0x0
+#define B0_PMC		 	0x0	/* normal */
+
+/* BANK1CON */
+#define B1_Tacs		 	0x0	/*  0clk */
+#define B1_Tcos		 	0x0	/*  0clk */
+#define B1_Tacc		 	0x7	/* 14clk */
+#define B1_Tcoh		 	0x0	/*  0clk */
+#define B1_Tah		 	0x0	/*  0clk */
+#define B1_Tacp		 	0x0
+#define B1_PMC		 	0x0
+
+#define B2_Tacs		 	0x0
+#define B2_Tcos		 	0x0
+#define B2_Tacc		 	0x7
+#define B2_Tcoh		 	0x0
+#define B2_Tah		 	0x0
+#define B2_Tacp		 	0x0
+#define B2_PMC		 	0x0
+
+#define B3_Tacs		 	0x0	/*  0clk */
+#define B3_Tcos		 	0x3	/*  4clk */
+#define B3_Tacc		 	0x7	/* 14clk */
+#define B3_Tcoh		 	0x1	/*  1clk */
+#define B3_Tah		 	0x0	/*  0clk */
+#define B3_Tacp		 	0x3     /*  6clk */
+#define B3_PMC		 	0x0	/* normal */
+
+#define B4_Tacs		 	0x0	/*  0clk */
+#define B4_Tcos		 	0x0	/*  0clk */
+#define B4_Tacc		 	0x7	/* 14clk */
+#define B4_Tcoh		 	0x0	/*  0clk */
+#define B4_Tah		 	0x0	/*  0clk */
+#define B4_Tacp		 	0x0
+#define B4_PMC		 	0x0	/* normal */
+
+#define B5_Tacs		 	0x0	/*  0clk */
+#define B5_Tcos		 	0x0	/*  0clk */
+#define B5_Tacc		 	0x7	/* 14clk */
+#define B5_Tcoh		 	0x0	/*  0clk */
+#define B5_Tah		 	0x0	/*  0clk */
+#define B5_Tacp		 	0x0
+#define B5_PMC		 	0x0	/* normal */
+
+#define B6_MT		 	0x3	/* SDRAM */
+#define B6_Trcd	 	 	0x1
+#define B6_SCAN		 	0x1	/* 9bit */
+
+#define B7_MT		 	0x3	/* SDRAM */
+#define B7_Trcd		 	0x1	/* 3clk */
+#define B7_SCAN		 	0x1	/* 9bit */
+
+/* REFRESH parameter */
+#define REFEN		 	0x1	/* Refresh enable */
+#define TREFMD		 	0x0	/* CBR(CAS before RAS)/Auto refresh */
+#define Trp		 	0x0	/* 2clk */
+#define Trc		 	0x3	/* 7clk */
+#define Tchr		 	0x2	/* 3clk */
+#define REFCNT		 	1113	/* period=15.6us, HCLK=60Mhz, (2048+1-15.6*60) */
+/**************************************/
+
+/* arm920t sys clock config */
+#define LOCKTIME 0x4c000000
+#define MPLLCON 0x4c000004
+#define UPLLCON 0x4c000008
+#define MPLLCON_VAL ((0x7f << 12)| (0x2 <<4 ) | 0x1)
+#define UPLLCON_VAL ((0x3c << 12) | (0x4 << 4)| 0x2)
+/****************************/
+
+
+
+_TEXT_BASE:
+	.word	CONFIG_SYS_TEXT_BASE
+
+.globl sysclock_init
+sysclock_init:
+	/**who knows what is it?**/
+	mrc p15,0,r1,c1,c0,0
+	orr r1,r1,#0xc000000
+	mcr p15,0,r1,c1,c0,0
+
+	ldr r0,=MPLLCON
+	ldr r1,=MPLLCON_VAL
+	str r1 , [r0]
+
+	ldr r0, =UPLLCON
+	ldr r1 ,=UPLLCON_VAL
+	str r1 , [r0]
+
+	mov r1 , #0x100
+	mov r0 , #0
+
+	/**just delay for a short time**/
+loop1: 
+	add r0,r0,#1
+	cmp r0,r1
+	bne loop1
+	
+	mov pc , lr	
+
+.globl lowlevel_init
+lowlevel_init:
+
+	/* need to config the sys clock*/
+	mov ip , lr
+	bl sysclock_init
+	mov lr , ip
+	
+	/* memory control configuration */
+	/* make r0 relative the current location so that it */
+	/* reads SMRDATA out of FLASH rather than memory ! */
+	ldr     r0, =SMRDATA
+	adr     r2 , SMRDATA
+	ldr	r1, _TEXT_BASE
+	sub	r0, r0, r1
+	ldr	r1, =BWSCON	/* Bus Width Status Controller */
+	add     r2, r0, #13*4
+0:
+	ldr     r3, [r0], #4
+	str     r3, [r1], #4
+	cmp     r2, r0
+	bne     0b
+	
+	ldr  r0 , =#CONFIG_SYS_TEXT_BASE
+	ldr  r1 , =#0
+	ldr  r2 , =#0x30000
+	mov ip , lr
+	bl nand_read_ll
+	mov lr , ip
+	/* everything is fine now */
+	mov	pc, lr
+
+	.ltorg
+/* the literal pools origin */
+
+SMRDATA:
+    .word (0+(B1_BWSCON<<4)+(B2_BWSCON<<8)+(B3_BWSCON<<12)+(B4_BWSCON<<16)+(B5_BWSCON<<20)+(B6_BWSCON<<24)+(B7_BWSCON<<28))
+    .word ((B0_Tacs<<13)+(B0_Tcos<<11)+(B0_Tacc<<8)+(B0_Tcoh<<6)+(B0_Tah<<4)+(B0_Tacp<<2)+(B0_PMC))
+    .word ((B1_Tacs<<13)+(B1_Tcos<<11)+(B1_Tacc<<8)+(B1_Tcoh<<6)+(B1_Tah<<4)+(B1_Tacp<<2)+(B1_PMC))
+    .word ((B2_Tacs<<13)+(B2_Tcos<<11)+(B2_Tacc<<8)+(B2_Tcoh<<6)+(B2_Tah<<4)+(B2_Tacp<<2)+(B2_PMC))
+    .word ((B3_Tacs<<13)+(B3_Tcos<<11)+(B3_Tacc<<8)+(B3_Tcoh<<6)+(B3_Tah<<4)+(B3_Tacp<<2)+(B3_PMC))
+    .word ((B4_Tacs<<13)+(B4_Tcos<<11)+(B4_Tacc<<8)+(B4_Tcoh<<6)+(B4_Tah<<4)+(B4_Tacp<<2)+(B4_PMC))
+    .word ((B5_Tacs<<13)+(B5_Tcos<<11)+(B5_Tacc<<8)+(B5_Tcoh<<6)+(B5_Tah<<4)+(B5_Tacp<<2)+(B5_PMC))
+    .word ((B6_MT<<15)+(B6_Trcd<<2)+(B6_SCAN))
+    .word ((B7_MT<<15)+(B7_Trcd<<2)+(B7_SCAN))
+    .word ((REFEN<<23)+(TREFMD<<22)+(Trp<<20)+(Trc<<18)+(Tchr<<16)+REFCNT)
+    .word 0x32
+    .word 0x30
+    .word 0x30
diff -urN tempuboot2017/u-boot-2017.01/board/samsung/smdk2440/MAINTAINERS ./u-boot-2017.01/board/samsung/smdk2440/MAINTAINERS
--- tempuboot2017/u-boot-2017.01/board/samsung/smdk2440/MAINTAINERS	1969-12-31 16:00:00.000000000 -0800
+++ ./u-boot-2017.01/board/samsung/smdk2440/MAINTAINERS	2019-12-30 05:13:25.071695838 -0800
@@ -0,0 +1,6 @@
+SMDK2440 BOARD
+M:	Minkyu Kang <mk7.kang@samsung.com>
+S:	Maintained
+F:	board/samsung/smdk2440/
+F:	include/configs/smdk2440.h
+F:	configs/s3c2440_defconfig
diff -urN tempuboot2017/u-boot-2017.01/board/samsung/smdk2440/Makefile ./u-boot-2017.01/board/samsung/smdk2440/Makefile
--- tempuboot2017/u-boot-2017.01/board/samsung/smdk2440/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ ./u-boot-2017.01/board/samsung/smdk2440/Makefile	2019-12-30 23:21:43.589476764 -0800
@@ -0,0 +1,5 @@
+obj-y += dummy.o
+obj-y += lowlevel_init.o
+obj-y += nand_read.o
+obj-y += s3c2440.o
+obj-y += flash.o
diff -urN tempuboot2017/u-boot-2017.01/board/samsung/smdk2440/Makefilebk ./u-boot-2017.01/board/samsung/smdk2440/Makefilebk
--- tempuboot2017/u-boot-2017.01/board/samsung/smdk2440/Makefilebk	1969-12-31 16:00:00.000000000 -0800
+++ ./u-boot-2017.01/board/samsung/smdk2440/Makefilebk	2019-12-30 16:57:15.621842338 -0800
@@ -0,0 +1,51 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= s3c2440.o nand_read.o flash.o
+SOBJS	:= lowlevel_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN tempuboot2017/u-boot-2017.01/board/samsung/smdk2440/nand_flash.c ./u-boot-2017.01/board/samsung/smdk2440/nand_flash.c
--- tempuboot2017/u-boot-2017.01/board/samsung/smdk2440/nand_flash.c	1969-12-31 16:00:00.000000000 -0800
+++ ./u-boot-2017.01/board/samsung/smdk2440/nand_flash.c	2019-12-31 20:25:48.486643839 -0800
@@ -0,0 +1,96 @@
+#include <common.h>
+
+#include <asm/arch-s3c24x0/s3c24x0_cpu.h>
+
+
+	DECLARE_GLOBAL_DATA_PTR;
+
+#define s3c2440_NFSTAT_READY    (1<<0)
+#define s3c2440_NFCONT_nFCE             (1<<1)
+
+	/*chip select */
+static inline struct s3c24x0_nand *s3c24x0_get_base_nand(void);
+
+static void s3c2440_nand_select_chip(struct mtd_info *mtd,int chip) {
+
+	struct s3c24x0_nand * s3c2440_nand = s3c24x0_get_base_nand();
+
+	if(chip == -1) {
+	      s3c2440_nand->nfcont |=s3c2440_NFCONT_nFCE;
+	}
+	else {
+	     s3c2440_nand->nfcont &=~s3c2440_NFCONT_nFCE;
+	}
+}
+
+	/*command and control */
+	static void s3c2440_nand_hwcontrol(struct mtd_info *mtd,int cmd) {
+
+	struct s3c24x0_nand * s3c2440_nand = s3c24x0_get_base_nand();
+	struct  nand_chip *chip = mtd->priv;
+
+	switch (cmd) {
+
+	     case NAND_NCE:
+	//    case NAND_CTL_CLRNCE:
+	             printf("%s:called for NCE/n",__FUNCTION__);
+	            break;
+	     case NAND_CLE:
+	             chip->IO_ADDR_W = (void *) &s3c2440_nand->nfcmd;
+	            break;
+	     case NAND_ALE:
+	             chip->IO_ADDR_W = (void *) &s3c2440_nand->nfaddr;
+	             break;
+	                      /*NAND_CTL_CLRCLE*/
+	                      /*NAND_CTL_CLRALE*/
+
+	     default:
+	             chip->IO_ADDR_W = (void *) &s3c2440_nand->nfdata;
+	             break;
+	}
+	}
+
+	/*inspect NAND status : 0 busy,1 free*/
+	static int s3c2440_nand_devready(struct mtd_info *mtd) {
+
+	struct s3c24x0_nand * s3c2440_nand = s3c24x0_get_base_nand();
+
+	return (s3c2440_nand->nfstat & s3c2440_NFSTAT_READY);
+
+
+
+		}
+
+	/*set NAND time seq */
+	static void s3c24x0_nand_inithw(void) {
+
+	struct s3c24x0_nand * s3c2440_nand = s3c24x0_get_base_nand();
+
+#define TACLS   0
+#define TWRPH0  4
+#define TWRPH1  2
+
+
+	     s3c2440_nand->nfconf = (TACLS << 12) | (TWRPH0 << 8) | (TWRPH1 << 4);
+	     s3c2440_nand->nfcont = (1<< 4) | (0<<1) | (1<<0);
+	}
+
+	/*invoke by drivers/nand/nand.c,initialize nand hardware */
+	void board_nand_init(struct nand_chip *chip) {
+
+	struct s3c24x0_nand * s3c2440_nand = s3c24x0_get_base_nand();
+	s3c24x0_nand_inithw();
+
+
+	     chip->IO_ADDR_R = (void *)&s3c2440_nand->nfdata;
+	      chip->IO_ADDR_W = (void *)&s3c2440_nand->nfdata;
+	      chip->hwcontrol = s3c2440_nand_hwcontrol;
+
+	     chip->dev_ready = s3c2440_nand_devready;
+	      chip->select_chip = s3c2440_nand_select_chip;
+	      chip->options = 0;
+
+	chip->eccmode = NAND_ECC_SOFT;
+	}
+#endif
+
diff -urN tempuboot2017/u-boot-2017.01/board/samsung/smdk2440/nand_readbk.c ./u-boot-2017.01/board/samsung/smdk2440/nand_readbk.c
--- tempuboot2017/u-boot-2017.01/board/samsung/smdk2440/nand_readbk.c	1969-12-31 16:00:00.000000000 -0800
+++ ./u-boot-2017.01/board/samsung/smdk2440/nand_readbk.c	2019-12-30 16:57:15.621842338 -0800
@@ -0,0 +1,90 @@
+/* 
+ * vivi/s3c2410/nand_read.c: Simple NAND read functions for booting from NAND
+ *
+  * Copyright (C) 2002 MIZI Research, Inc.
+  *
+  * Author: Hwang, Chideok <hwang@mizi.com>
+  * Date  : $Date: 2004/02/04 06:22:24 $
+ *
+   * $Revision: 1.1.1.1 $
+  Id: 
+  * History
+   *
+   * 2002-05-xx: Hwang, Chideok <hwang@mizi.com>
+   *
+   * 2002-05-xx: Chan Gyun Jeong <cgjeong@mizi.com>
+   *
+   * 2002-08-10: Yong-iL Joh <tolkien@mizi.com>
+   *
+   */
+  
+  #include <config.h>
+  
+  #define __REGb(x)       (*(volatile unsigned char *)(x))
+  #define __REGi(x)       (*(volatile unsigned int *)(x))
+  #define NF_BASE         0x4e000000
+  
+ #if defined(CONFIG_S3C2440)
+  
+#define NFCONF          __REGi(NF_BASE + 0x0)
+#define NFCONT          __REGi(NF_BASE + 0x4)
+#define NFCMD           __REGb(NF_BASE + 0x8)
+#define NFADDR          __REGb(NF_BASE + 0xC)
+#define NFDATA          __REGb(NF_BASE + 0x10)
+#define NFSTAT          __REGb(NF_BASE + 0x20)
+ 
+  //#define GPDAT         __REGi(GPIO_CTL_BASE+oGPIO_F+oGPIO_DAT)
+ 
+  #define NAND_CHIP_ENABLE  (NFCONT &= ~(1<<1))
+  #define NAND_CHIP_DISABLE (NFCONT |=  (1<<1))
+  #define NAND_CLEAR_RB     (NFSTAT |=  (1<<2))
+  #define NAND_DETECT_RB    { while(! (NFSTAT&(1<<2)) );}
+  
+  #define BUSY 4
+  inline void wait_idle(void) {
+          while(!(NFSTAT & BUSY));
+          NFSTAT |= BUSY;
+  }
+  
+  #define NAND_SECTOR_SIZE        512
+  #define NAND_BLOCK_MASK         (NAND_SECTOR_SIZE - 1)
+  
+  /* low level nand read function */
+  int nand_read_ll(unsigned char *buf, unsigned long start_addr, int size)
+  {
+          int i, j;
+  
+          if ((start_addr & NAND_BLOCK_MASK) || (size & NAND_BLOCK_MASK)) {
+                  return -1;      /* invalid alignment */
+          }
+  
+          NAND_CHIP_ENABLE;
+  
+          for(i=start_addr; i < (start_addr + size);) {
+  
+                  /* READ0 */
+                  NAND_CLEAR_RB;
+                  NFCMD = 0;
+  
+                  /* Write Address */
+                  NFADDR = i & 0xff;
+                  NFADDR = (i >> 9) & 0xff;
+                  NFADDR = (i >> 17) & 0xff;
+                  NFADDR = (i >> 25) & 0xff;
+  
+                          /*is nand flash ready ?*/
+                  NAND_DETECT_RB;
+ 
+                          /*ready a page data into buf*/
+                  for(j=0; j < NAND_SECTOR_SIZE; j++, i++) {
+                          *buf = (NFDATA & 0xff);
+                          buf++;
+                  }
+          }
+          NAND_CHIP_DISABLE;
+          return 0;
+  }
+  #endif
+
+
+
diff -urN tempuboot2017/u-boot-2017.01/board/samsung/smdk2440/nand_read.S ./u-boot-2017.01/board/samsung/smdk2440/nand_read.S
--- tempuboot2017/u-boot-2017.01/board/samsung/smdk2440/nand_read.S	1969-12-31 16:00:00.000000000 -0800
+++ ./u-boot-2017.01/board/samsung/smdk2440/nand_read.S	2019-12-31 17:22:43.462602272 -0800
@@ -0,0 +1,191 @@
+/*
+ * Memory Setup stuff - taken from blob memsetup.S
+ *
+ * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl) and
+ *                     Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl)
+ *
+ * Modified for the Samsung SMDK2410 by
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+
+#include <config.h>
+#include <version.h>
+
+
+/* NAND FLASH DEF*/
+#define NF_BASE 0x4e000000
+
+#define NAND_SECTOR_SIZE		512
+#define NAND_BLOCK_MASK 		(NAND_SECTOR_SIZE - 1)
+
+#define NFCONF          (NF_BASE + 0x0)
+#define NFCONT          (NF_BASE + 0x4)
+#define NFCMD           (NF_BASE + 0x8)
+#define NFADDR          (NF_BASE + 0xC)
+#define NFDATA          (NF_BASE + 0x10)
+#define NFSTAT          (NF_BASE + 0x20)
+
+#define BUSY 0x4
+#define ENABLE 0x2
+/*get the flash status whether busy or not*/
+
+/*enable the nand*/
+.globl nand_enable
+nand_enable:
+	ldr r5 , =#NFCONT
+	ldr r6 , [r5]
+	bic r7 , r6 , #ENABLE
+	str r7 , [r5]
+	mov pc , lr
+	
+/*disalbe the nand*/
+.globl nand_disable
+nand_disable:
+	ldr r5 , =#NFCONT
+	ldr r6 , [r5]
+	orr r7 , r6 , #ENABLE
+	str r7  , [r5]
+	mov pc , lr
+
+	
+.globl nand_status
+nand_status:
+
+	ldr r6 , =#NFSTAT
+	ldr r5 , [r6]
+	tst r5 , #BUSY
+	bne nand_status 
+	orr r5 , r5 , #BUSY
+	str r5 , [r6]
+	mov pc , lr
+
+.globl nand_flash_init
+nand_flash_init:
+	/**init nand flash**/
+	ldr r1, =#NFCONF
+	ldr r2 , =(7 << 12 | 7 << 8 | 7 << 4 | 0 <<0)
+	str r2 , [r1]
+	ldr r2 , [r1]
+	
+	ldr r1, =#NFCONT
+	ldr r2 , =((1 << 4) | (0<< 1) | (1 << 0) )
+	str r2 , [r1]
+	ldr r2 , [r1]
+
+	ldr r1, =#NFSTAT
+	mov r2 ,#0x6
+	str r2 , [r1]
+	ldr r2 , [r1]
+	
+	ldr r1, =#NFCMD
+	mov r2 , #0xFF
+	str r2 , [r1]
+
+	mov r3 , #0
+
+nand_delay1:
+	add r3,r3,#1
+	cmp r3 , #0x100
+	blt nand_delay1	
+	
+	mov pc , lr
+	
+		
+/**r0(buf) r1(start addr) r2(size) **/
+.globl nand_read_ll
+nand_read_ll:
+	mov ip , lr
+	bl nand_flash_init
+	mov lr , ip
+	ldr r6 , =#NAND_BLOCK_MASK	
+	and r3 , r1 , r6
+	cmp r3 , #0
+	bne retout /*not align with 512*/
+	
+	and r3 , r2 , r6
+	cmp r3 , #0
+	bne retout   /*not align with 512*/
+	
+	mov r3 , #0
+	mov r4 , #0
+
+	mov ip , lr 
+	bl nand_enable
+	mov lr , ip
+
+	mov r3 , r1
+
+0:	add r5 , r1 , r2
+	cmp r3 , r5
+	bge retout
+
+	ldr r5 , =#NFSTAT
+	ldr r6 , [r5]
+	orr r6 , r6 , #BUSY
+	str r6 ,[r5]
+
+	ldr r5 , =#NFCMD
+	mov r6 , #0
+	str r6 , [r5]
+
+	ldr r5 , =#NFADDR
+	and r6 , r3 , #0xff
+	str r6 , [r5]
+	
+	mov r6 , r3 , lsr#9
+	and r6 , r6 , #0xff
+	str r6 , [r5]
+
+	mov r6 , r3 , lsr#17
+	and r6 , r6 , #0xff
+	str r6 , [r5]
+	
+	mov r6 , r3 , lsr#25
+	and r6 , r6 , #0xff
+	str r6 , [r5]	
+
+	mov ip , lr
+	bl nand_status
+	mov lr , ip
+	
+	mov r4 , #0
+	
+1:	cmp r4 , #NAND_SECTOR_SIZE
+	bge 0b
+	ldr r5  , =#NFDATA
+	ldr r6 , [r5]
+	and r6 , r6 ,#0xff
+	str r6 , [r0]
+	add r0 , r0 ,#1
+	add r4 , r4 ,#1
+	add r3 , r3 ,#1
+	b 1b
+	
+retout:
+	mov ip , lr
+	bl nand_disable
+	mov lr , ip
+	
+	mov pc , lr
+ 
diff -urN tempuboot2017/u-boot-2017.01/board/samsung/smdk2440/s3c2440.c ./u-boot-2017.01/board/samsung/smdk2440/s3c2440.c
--- tempuboot2017/u-boot-2017.01/board/samsung/smdk2440/s3c2440.c	1969-12-31 16:00:00.000000000 -0800
+++ ./u-boot-2017.01/board/samsung/smdk2440/s3c2440.c	2019-12-30 23:35:24.433416638 -0800
@@ -0,0 +1,106 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch-s3c24x0/s3c24x0_cpu.h>
+//#include <asm/arch-s3c24x0/s3c24x0.h>
+
+
+DECLARE_GLOBAL_DATA_PTR;
+
+
+static inline void delay (unsigned long loops)
+{
+	__asm__ volatile ("1:\n"
+	  "subs %0, %1, #1\n"
+	  "bne 1b":"=r" (loops):"0" (loops));
+}
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+	struct s3c24x0_gpio *  gpio = s3c24x0_get_base_gpio();
+
+#if 0
+	/* to reduce PLL lock time, adjust the LOCKTIME register */
+	clk_power->CLKCON = 0x5;
+	clk_power->LOCKTIME = 0xFFFFFF;
+	
+
+	/* configure MPLL */
+	clk_power->MPLLCON = ((M_MDIV << 12) + (M_PDIV << 4) + M_SDIV);
+
+	/* some delay between MPLL and UPLL */
+	delay (4000);
+
+	/* configure UPLL */
+	clk_power->UPLLCON = ((U_M_MDIV << 12) + (U_M_PDIV << 4) + U_M_SDIV);
+
+	/* some delay between MPLL and UPLL */
+	delay (8000);
+#endif
+
+	/* set up the I/O ports */
+	gpio->gpacon = 0x007FFFFF;
+	gpio->gpbcon = 0x00044555;
+	gpio->gpbup = 0x000007FF;
+	gpio->gpccon = 0xAAAAAAAA;
+	gpio->gpcup = 0x0000FFFF;
+	gpio->gpdcon = 0xAAAAAAAA;
+	gpio->gpdup = 0x0000FFFF;
+	gpio->gpecon = 0xAAAAAAAA;
+	gpio->gpeup = 0x0000FFFF;
+	gpio->gpfcon = 0x000055AA;
+	gpio->gpfup = 0x000000FF;
+	gpio->gpgcon = 0xFF95FFBA;
+	gpio->gpgup = 0x0000FFFF;
+	gpio->gphcon = 0x002AFAAA;
+	gpio->gphup = 0x000007FF;
+
+	/* arch number of SMDK2410-Board */
+	gd->bd->bi_arch_number = MACH_TYPE_S3C2440;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = 0x30000100;
+
+	icache_enable();
+	dcache_enable();
+	gpio->gpfdat = 0xbf;
+
+	return 0;
+}
+
+int dram_init (void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+
+	return 0;
+}
diff -urN tempuboot2017/u-boot-2017.01/board/samsung/smdk2440/u-boot.lds111111 ./u-boot-2017.01/board/samsung/smdk2440/u-boot.lds111111
--- tempuboot2017/u-boot-2017.01/board/samsung/smdk2440/u-boot.lds111111	1969-12-31 16:00:00.000000000 -0800
+++ ./u-boot-2017.01/board/samsung/smdk2440/u-boot.lds111111	2019-12-30 16:57:15.621842338 -0800
@@ -0,0 +1,57 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+/*OUTPUT_FORMAT("elf32-arm", "elf32-arm", "elf32-arm")*/
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/arm920t/start.o	(.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff -urN tempuboot2017/u-boot-2017.01/common/init/board_init.c ./u-boot-2017.01/common/init/board_init.c
--- tempuboot2017/u-boot-2017.01/common/init/board_init.c	2017-01-09 08:57:05.000000000 -0800
+++ ./u-boot-2017.01/common/init/board_init.c	2019-12-30 18:09:35.505329206 -0800
@@ -120,6 +120,7 @@
 	 */
 
 	gd_ptr = (struct global_data *)base;
+	barrier();
 	/* zero the area */
 #ifdef _USE_MEMCPY
 	memset(gd_ptr, '\0', sizeof(*gd));
diff -urN tempuboot2017/u-boot-2017.01/configs/s3c2440_defconfig ./u-boot-2017.01/configs/s3c2440_defconfig
--- tempuboot2017/u-boot-2017.01/configs/s3c2440_defconfig	1969-12-31 16:00:00.000000000 -0800
+++ ./u-boot-2017.01/configs/s3c2440_defconfig	2019-12-30 17:53:53.711187016 -0800
@@ -0,0 +1,23 @@
+CONFIG_ARM=y
+CONFIG_TARGET_S3C2440=y
+CONFIG_S3C24X0=y
+CONFIG_SYS_CONFIG_NAME=y
+CONFIG_SYS_MALLOC_F_LEN=0x8000
+#CONFIG_DISTRO_DEFAULTS=y
+# CONFIG_DISPLAY_CPUINFO is not set
+# CONFIG_DISPLAY_BOARDINFO is not set
+# CONFIG_CMD_CONSOLE is not set
+# CONFIG_CMD_BOOTD is not set
+# CONFIG_CMD_IMLS is not set
+# CONFIG_CMD_XIMG is not set
+# CONFIG_CMD_EDITENV is not set
+# CONFIG_CMD_ENV_EXISTS is not set
+# CONFIG_CMD_LOADB is not set
+# CONFIG_CMD_LOADS is not set
+#CONFIG_CMD_MMC=y
+# CONFIG_CMD_FPGA is not set
+# CONFIG_CMD_ITEST is not set
+# CONFIG_CMD_SETEXPR is not set
+# CONFIG_CMD_NFS is not set
+# CONFIG_CMD_MISC is not set
+#CONFIG_OF_LIBFDT=y
diff -urN tempuboot2017/u-boot-2017.01/configs/vexpress_ca9x4_defconfig ./u-boot-2017.01/configs/vexpress_ca9x4_defconfig
--- tempuboot2017/u-boot-2017.01/configs/vexpress_ca9x4_defconfig	2017-01-09 08:57:05.000000000 -0800
+++ ./u-boot-2017.01/configs/vexpress_ca9x4_defconfig	1969-12-31 16:00:00.000000000 -0800
@@ -1,20 +0,0 @@
-CONFIG_ARM=y
-CONFIG_TARGET_VEXPRESS_CA9X4=y
-CONFIG_DISTRO_DEFAULTS=y
-# CONFIG_DISPLAY_CPUINFO is not set
-# CONFIG_DISPLAY_BOARDINFO is not set
-# CONFIG_CMD_CONSOLE is not set
-# CONFIG_CMD_BOOTD is not set
-# CONFIG_CMD_IMLS is not set
-# CONFIG_CMD_XIMG is not set
-# CONFIG_CMD_EDITENV is not set
-# CONFIG_CMD_ENV_EXISTS is not set
-# CONFIG_CMD_LOADB is not set
-# CONFIG_CMD_LOADS is not set
-CONFIG_CMD_MMC=y
-# CONFIG_CMD_FPGA is not set
-# CONFIG_CMD_ITEST is not set
-# CONFIG_CMD_SETEXPR is not set
-# CONFIG_CMD_NFS is not set
-# CONFIG_CMD_MISC is not set
-CONFIG_OF_LIBFDT=y
diff -urN tempuboot2017/u-boot-2017.01/drivers/mtd/nand/s3c2410_nand.c ./u-boot-2017.01/drivers/mtd/nand/s3c2410_nand.c
--- tempuboot2017/u-boot-2017.01/drivers/mtd/nand/s3c2410_nand.c	2017-01-09 08:57:05.000000000 -0800
+++ ./u-boot-2017.01/drivers/mtd/nand/s3c2410_nand.c	2019-12-31 23:40:54.417799153 -0800
@@ -8,8 +8,8 @@
 #include <common.h>
 
 #include <nand.h>
-#include <asm/arch/s3c24x0_cpu.h>
 #include <asm/io.h>
+#include <asm/arch-s3c24x0/s3c24x0_cpu.h>
 
 #define S3C2410_NFCONF_EN          (1<<15)
 #define S3C2410_NFCONF_512BYTE     (1<<14)
@@ -20,6 +20,8 @@
 #define S3C2410_NFCONF_TWRPH0(x)   ((x)<<4)
 #define S3C2410_NFCONF_TWRPH1(x)   ((x)<<0)
 
+
+
 #define S3C2410_ADDR_NALE 4
 #define S3C2410_ADDR_NCLE 8
 
@@ -112,8 +114,8 @@
 {
 	u_int32_t cfg;
 	u_int8_t tacls, twrph0, twrph1;
-	struct s3c24x0_clock_power *clk_power = s3c24x0_get_base_clock_power();
 	struct s3c24x0_nand *nand_reg = s3c24x0_get_base_nand();
+	struct s3c24x0_clock_power *clk_power = s3c24x0_get_base_clock_power();
 
 	debug("board_nand_init()\n");
 
diff -urN tempuboot2017/u-boot-2017.01/drivers/serial/Makefile ./u-boot-2017.01/drivers/serial/Makefile
--- tempuboot2017/u-boot-2017.01/drivers/serial/Makefile	2017-01-09 08:57:05.000000000 -0800
+++ ./u-boot-2017.01/drivers/serial/Makefile	2019-12-31 00:03:45.467437408 -0800
@@ -9,7 +9,10 @@
 obj-y += serial-uclass.o
 obj-$(CONFIG_PL01X_SERIAL) += serial_pl01x.o
 else
+
+ifndef CONFIG_TARGET_S3C2440
 obj-y += serial.o
+endif
 obj-$(CONFIG_PL010_SERIAL) += serial_pl01x.o
 obj-$(CONFIG_PL011_SERIAL) += serial_pl01x.o
 obj-$(CONFIG_SYS_NS16550_SERIAL) += serial_ns16550.o
diff -urN tempuboot2017/u-boot-2017.01/include/configs/smdk2440.h ./u-boot-2017.01/include/configs/smdk2440.h
--- tempuboot2017/u-boot-2017.01/include/configs/smdk2440.h	1969-12-31 16:00:00.000000000 -0800
+++ ./u-boot-2017.01/include/configs/smdk2440.h	2019-12-31 23:55:26.986356266 -0800
@@ -0,0 +1,210 @@
+/*
+ * (C) Copyright 2009 Samsung Electronics
+ * Minkyu Kang <mk7.kang@samsung.com>
+ * HeungJun Kim <riverful.kim@samsung.com>
+ * Inki Dae <inki.dae@samsung.com>
+ *
+ * Configuation settings for the SAMSUNG SMDKC100 board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_SAMSUNG		1	/* in a SAMSUNG core */
+#define CONFIG_S3C2440          1
+#define CONFIG_SYS_MAX_FLASH_BANKS 1
+#define CONFIG_ARCH_CPU_INIT
+#define CONFIG_SYS_MAX_NAND_DEVICE 1
+#define CONFIG_SYS_NAND_BASE 0
+/* input clock of PLL: SMDKC100 has 12MHz input clock */
+#define CONFIG_SYS_CLK_FREQ		12000000
+
+/* DRAM Base */
+#define CONFIG_SYS_SDRAM_BASE		0x30000000
+
+/* Text Base */
+#define CONFIG_SYS_TEXT_BASE		0x34800000
+
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_INITRD_TAG
+#define CONFIG_CMDLINE_EDITING
+
+/*
+ * Size of malloc() pool
+ * 1MB = 0x100000, 0x100000 = 1024 * 1024
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + (1 << 20))
+
+/*
+ * select serial console configuration
+ */
+#define CONFIG_SERIAL0			0	/* use SERIAL 0 on SMDKC100 */
+
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_BAUDRATE			115200
+
+/***********************************************************
+ * Command definition
+ ***********************************************************/
+#define  CONFIG_CMD_NAND
+#define CONFIG_NAND_S3C2410
+
+
+#define CONFIG_CMD_REGINFO
+
+
+#define MTDIDS_DEFAULT		"onenand0=s3c-onenand"
+#define MTDPARTS_DEFAULT	"mtdparts=s3c-onenand:256k(bootloader)"\
+				",128k@0x40000(params)"\
+				",3m@0x60000(kernel)"\
+				",16m@0x360000(test)"\
+				",-(UBI)"
+
+#define NORMAL_MTDPARTS_DEFAULT MTDPARTS_DEFAULT
+
+#define CONFIG_BOOTCOMMAND	"run ubifsboot"
+
+#define CONFIG_RAMDISK_BOOT	"root=/dev/ram0 rw rootfstype=ext2" \
+				" console=ttySAC0,115200n8" \
+				" mem=128M"
+
+#define CONFIG_COMMON_BOOT	"console=ttySAC0,115200n8" \
+				" mem=128M " \
+				" " MTDPARTS_DEFAULT
+
+#define CONFIG_BOOTARGS	"root=/dev/mtdblock5 ubi.mtd=4" \
+			" rootfstype=cramfs " CONFIG_COMMON_BOOT
+
+#define CONFIG_UPDATEB	"updateb=onenand erase 0x0 0x40000;" \
+			" onenand write 0x32008000 0x0 0x40000\0"
+
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	CONFIG_UPDATEB \
+	"updatek=" \
+		"onenand erase 0x60000 0x300000;" \
+		"onenand write 0x31008000 0x60000 0x300000\0" \
+	"updateu=" \
+		"onenand erase block 147-4095;" \
+		"onenand write 0x32000000 0x1260000 0x8C0000\0" \
+	"bootk=" \
+		"onenand read 0x30007FC0 0x60000 0x300000;" \
+		"bootm 0x30007FC0\0" \
+	"flashboot=" \
+		"set bootargs root=/dev/mtdblock${bootblock} " \
+		"rootfstype=${rootfstype} " \
+		"ubi.mtd=${ubiblock} ${opts} " CONFIG_COMMON_BOOT ";" \
+		"run bootk\0" \
+	"ubifsboot=" \
+		"set bootargs root=ubi0!rootfs rootfstype=ubifs " \
+		" ubi.mtd=${ubiblock} ${opts} " CONFIG_COMMON_BOOT "; " \
+		"run bootk\0" \
+	"boottrace=setenv opts initcall_debug; run bootcmd\0" \
+	"android=" \
+		"set bootargs root=ubi0!ramdisk ubi.mtd=${ubiblock} " \
+		"rootfstype=ubifs init=/init.sh " CONFIG_COMMON_BOOT "; " \
+		"run bootk\0" \
+	"nfsboot=" \
+		"set bootargs root=/dev/nfs ubi.mtd=${ubiblock} " \
+		"nfsroot=${nfsroot},nolock " \
+		"ip=${ipaddr}:${serverip}:${gatewayip}:" \
+		"${netmask}:nowplus:usb0:off " CONFIG_COMMON_BOOT "; " \
+		"run bootk\0" \
+	"ramboot=" \
+		"set bootargs " CONFIG_RAMDISK_BOOT \
+		" initrd=0x33000000,8M ramdisk=8192\0" \
+	"rootfstype=cramfs\0" \
+	"mtdparts=" MTDPARTS_DEFAULT "\0" \
+	"meminfo=mem=128M\0" \
+	"nfsroot=/nfsroot/arm\0" \
+	"bootblock=5\0" \
+	"ubiblock=4\0" \
+	"ubi=enabled"
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_SYS_CBSIZE	256	/* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE	384	/* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS	16	/* max number of command args */
+/* Boot Argument Buffer Size */
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+/* memtest works on */
+#define CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + 0x5e00000)
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_SYS_SDRAM_BASE
+
+/* SMDKC100 has 1 banks of DRAM, we use only one in U-Boot */
+#define CONFIG_NR_DRAM_BANKS	1
+#define PHYS_SDRAM_1		CONFIG_SYS_SDRAM_BASE	/* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	(128 << 20)	/* 0x8000000, 128 MB Bank #1 */
+
+#define CONFIG_SYS_MONITOR_BASE	0x00000000
+
+#define PHYS_FLASH_1		0x00000000 /* Flash Bank #1 */
+
+#define CFG_FLASH_BASE		PHYS_FLASH_1
+
+#define CFG_ENV_SIZE		0x10000	/* Total Size of Environment Sector */
+#define CONFIG_SERIAL1          1	/* we use SERIAL 1 on SMDK2410 */
+#define CONFIG_SYS_NAND_MAX_CHIPS 1
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CONFIG_MACH_TYPE 362	
+
+#define CONFIG_SYS_MONITOR_LEN		(256 << 10)	/* 256 KiB */
+
+#if !defined(CONFIG_NAND_SPL) && (CONFIG_SYS_TEXT_BASE >= 0xc0000000)
+#define CONFIG_ENABLE_MMU
+#endif
+
+#ifdef CONFIG_ENABLE_MMU
+#define CONFIG_SYS_MAPPED_RAM_BASE	0xc0000000
+#else
+#define CONFIG_SYS_MAPPED_RAM_BASE	CONFIG_SYS_SDRAM_BASE
+#endif
+
+/*-----------------------------------------------------------------------
+ * Boot configuration
+ */
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+
+#define CONFIG_AMD_LV400	1	/* uncomment this if you have a LV400 flash */
+
+#ifdef CONFIG_AMD_LV400
+#define PHYS_FLASH_SIZE		0x00080000 /* 512KB */
+#define CFG_MAX_FLASH_SECT	(11)	/* max number of sectors on one chip */
+#define CFG_ENV_ADDR		(CFG_FLASH_BASE + 0x070000) /* addr of environment */
+#endif
+
+
+#define CONFIG_ENV_SIZE			(128 << 10)	/* 128KiB, 0x20000 */
+#define CONFIG_ENV_ADDR			(256 << 10)	/* 256KiB, 0x40000 */
+#define CONFIG_ENV_OFFSET		(256 << 10)	/* 256KiB, 0x40000 */
+#define CONFIG_ENV_IS_IN_FLASH          1
+
+
+#define CONFIG_SYS_INIT_SP_ADDR	(CONFIG_SYS_LOAD_ADDR + 0x1000000)
+
+/*
+ * Ethernet Contoller driver
+ */
+#ifdef CONFIG_CMD_NET
+#define CONFIG_SMC911X         1       /* we have a SMC9115 on-board   */
+#define CONFIG_SMC911X_16_BIT  1       /* SMC911X_16_BIT Mode          */
+#define CONFIG_SMC911X_BASE    0x98800300      /* SMC911X Drive Base   */
+#define CONFIG_ENV_SROM_BANK   3       /* Select SROM Bank-3 for Ethernet*/
+#endif /* CONFIG_CMD_NET */
+
+#endif	/* __CONFIG_H */
Binary files tempuboot2017/u-boot-2017.01/lib/efi_loader/helloworld.efi and ./u-boot-2017.01/lib/efi_loader/helloworld.efi differ
Binary files tempuboot2017/u-boot-2017.01/lib/efi_loader/helloworld.so and ./u-boot-2017.01/lib/efi_loader/helloworld.so differ
diff -urN tempuboot2017/u-boot-2017.01/run.sh ./u-boot-2017.01/run.sh
--- tempuboot2017/u-boot-2017.01/run.sh	1969-12-31 16:00:00.000000000 -0800
+++ ./u-boot-2017.01/run.sh	2019-07-23 03:31:47.255044533 -0700
@@ -0,0 +1,2 @@
+#! /bin/sh
+qemu-system-arm  -M vexpress-a9    -nographic  -m 512M -kernel u-boot
diff -urN tempuboot2017/u-boot-2017.01/scripts/kconfig/Makefile ./u-boot-2017.01/scripts/kconfig/Makefile
--- tempuboot2017/u-boot-2017.01/scripts/kconfig/Makefile	2017-01-09 08:57:05.000000000 -0800
+++ ./u-boot-2017.01/scripts/kconfig/Makefile	2019-12-26 18:54:54.618289978 -0800
@@ -5,6 +5,7 @@
 # SPDX-License-Identifier:	GPL-2.0
 #
 
+
 PHONY += xconfig gconfig menuconfig config silentoldconfig update-po-config \
 	localmodconfig localyesconfig
 
@@ -51,7 +52,7 @@
 	$(Q)perl $< --$@ $(srctree) $(Kconfig) > .tmp.config
 	$(Q)if [ -f .config ]; then 					\
 			cmp -s .tmp.config .config ||			\
-			(mv -f .config .config.old.1;			\
+			mv -f .config .config.old.1;			\
 			 mv -f .tmp.config .config;			\
 			 $(obj)/conf $(silent) --silentoldconfig $(Kconfig); \
 			 mv -f .config.old.1 .config.old)		\
diff -urN tempuboot2017/u-boot-2017.01/scripts/kconfig/merge_config.sh ./u-boot-2017.01/scripts/kconfig/merge_config.sh
--- tempuboot2017/u-boot-2017.01/scripts/kconfig/merge_config.sh	2017-01-09 08:57:05.000000000 -0800
+++ ./u-boot-2017.01/scripts/kconfig/merge_config.sh	2019-12-30 00:10:38.896952389 -0800
@@ -19,7 +19,7 @@
 #  but WITHOUT ANY WARRANTY; without even the implied warranty of
 #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 #  See the GNU General Public License for more details.
-
+set -x
 clean_up() {
 	rm -f $TMP_FILE
 	exit
